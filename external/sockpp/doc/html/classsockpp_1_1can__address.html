<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sockpp: sockpp::can_address Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sockpp
   </div>
   <div id="projectbrief">Modern C++ socket library wrapper</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sockpp</b></li><li class="navelem"><a class="el" href="classsockpp_1_1can__address.html">can_address</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classsockpp_1_1can__address-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">sockpp::can_address Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class that represents a Linux SocketCAN address.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="can__address_8h_source.html">can_address.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sockpp::can_address:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsockpp_1_1can__address.png" usemap="#sockpp::can_5Faddress_map" alt=""/>
  <map id="sockpp::can_5Faddress_map" name="sockpp::can_5Faddress_map">
<area href="classsockpp_1_1sock__address.html" title="Generic socket address." alt="sockpp::sock_address" shape="rect" coords="0,0,136,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb52f2768042e8d148ea72dc3c78dbb4" id="r_abb52f2768042e8d148ea72dc3c78dbb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb52f2768042e8d148ea72dc3c78dbb4">can_address</a> () noexcept</td></tr>
<tr class="memdesc:abb52f2768042e8d148ea72dc3c78dbb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an empty address.  <br /></td></tr>
<tr class="separator:abb52f2768042e8d148ea72dc3c78dbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb99e1a7491496a17c61c05fdd1d141b" id="r_aeb99e1a7491496a17c61c05fdd1d141b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb99e1a7491496a17c61c05fdd1d141b">can_address</a> (unsigned idx) noexcept</td></tr>
<tr class="memdesc:aeb99e1a7491496a17c61c05fdd1d141b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an address for binding to a specific CAN interface.  <br /></td></tr>
<tr class="separator:aeb99e1a7491496a17c61c05fdd1d141b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa634b4dc329dedd8d56f2413c79dd93c" id="r_aa634b4dc329dedd8d56f2413c79dd93c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa634b4dc329dedd8d56f2413c79dd93c">can_address</a> (const string &amp;<a class="el" href="#adf220acee4858b2b7c7e6b051639e3e9">iface</a>)</td></tr>
<tr class="memdesc:aa634b4dc329dedd8d56f2413c79dd93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an address for the specified CAN interface.  <br /></td></tr>
<tr class="separator:aa634b4dc329dedd8d56f2413c79dd93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28adbdc672a05a282d6245f5961a5f0d" id="r_a28adbdc672a05a282d6245f5961a5f0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28adbdc672a05a282d6245f5961a5f0d">can_address</a> (const sockaddr &amp;addr) noexcept</td></tr>
<tr class="memdesc:a28adbdc672a05a282d6245f5961a5f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the address by copying the specified structure.  <br /></td></tr>
<tr class="separator:a28adbdc672a05a282d6245f5961a5f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdc6027891cebad1244268e72301643" id="r_a3fdc6027891cebad1244268e72301643"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fdc6027891cebad1244268e72301643">can_address</a> (const <a class="el" href="classsockpp_1_1sock__address.html">sock_address</a> &amp;addr) noexcept</td></tr>
<tr class="memdesc:a3fdc6027891cebad1244268e72301643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the address by copying the specified structure.  <br /></td></tr>
<tr class="separator:a3fdc6027891cebad1244268e72301643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0efbdc456d6df93cb62490ee7ec660" id="r_a9d0efbdc456d6df93cb62490ee7ec660"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d0efbdc456d6df93cb62490ee7ec660">can_address</a> (const sockaddr_can &amp;addr) noexcept</td></tr>
<tr class="memdesc:a9d0efbdc456d6df93cb62490ee7ec660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the address by copying the specified structure.  <br /></td></tr>
<tr class="separator:a9d0efbdc456d6df93cb62490ee7ec660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf49506a3fc0e0c2b670bebfdad9b52d" id="r_acf49506a3fc0e0c2b670bebfdad9b52d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf49506a3fc0e0c2b670bebfdad9b52d">can_address</a> (const <a class="el" href="classsockpp_1_1can__address.html">can_address</a> &amp;addr) noexcept</td></tr>
<tr class="memdesc:acf49506a3fc0e0c2b670bebfdad9b52d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the address by copying the specified address.  <br /></td></tr>
<tr class="separator:acf49506a3fc0e0c2b670bebfdad9b52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e93d75f42bf1b4939500b68307f28eb" id="r_a0e93d75f42bf1b4939500b68307f28eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e93d75f42bf1b4939500b68307f28eb">is_set</a> () const noexcept override</td></tr>
<tr class="memdesc:a0e93d75f42bf1b4939500b68307f28eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the address is set to some value.  <br /></td></tr>
<tr class="separator:a0e93d75f42bf1b4939500b68307f28eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85126b3fea2f25cf908eae1336d30391" id="r_a85126b3fea2f25cf908eae1336d30391"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsockpp_1_1result.html">result</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85126b3fea2f25cf908eae1336d30391">get_iface</a> () const noexcept</td></tr>
<tr class="memdesc:a85126b3fea2f25cf908eae1336d30391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to get the name of the CAN interface for this address.  <br /></td></tr>
<tr class="separator:a85126b3fea2f25cf908eae1336d30391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf220acee4858b2b7c7e6b051639e3e9" id="r_adf220acee4858b2b7c7e6b051639e3e9"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf220acee4858b2b7c7e6b051639e3e9">iface</a> () const noexcept</td></tr>
<tr class="memdesc:adf220acee4858b2b7c7e6b051639e3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of the CAN interface for this address.  <br /></td></tr>
<tr class="separator:adf220acee4858b2b7c7e6b051639e3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bd23afd5ee4e16624b0ad3433e7590" id="r_a14bd23afd5ee4e16624b0ad3433e7590"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14bd23afd5ee4e16624b0ad3433e7590">index</a> () const noexcept</td></tr>
<tr class="memdesc:a14bd23afd5ee4e16624b0ad3433e7590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the index of the CAN interface for this address.  <br /></td></tr>
<tr class="separator:a14bd23afd5ee4e16624b0ad3433e7590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e78e39748afb7db8a7285557994134" id="r_af6e78e39748afb7db8a7285557994134"><td class="memItemLeft" align="right" valign="top">socklen_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6e78e39748afb7db8a7285557994134">size</a> () const override</td></tr>
<tr class="memdesc:af6e78e39748afb7db8a7285557994134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the address structure.  <br /></td></tr>
<tr class="separator:af6e78e39748afb7db8a7285557994134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28b359f745395930b01090f59aacf79" id="r_ab28b359f745395930b01090f59aacf79"><td class="memItemLeft" align="right" valign="top">const sockaddr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab28b359f745395930b01090f59aacf79">sockaddr_ptr</a> () const override</td></tr>
<tr class="memdesc:ab28b359f745395930b01090f59aacf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to this object cast to a const <em>sockaddr</em>.  <br /></td></tr>
<tr class="separator:ab28b359f745395930b01090f59aacf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1824f4b6ed8d252b6621b2e351209f1" id="r_af1824f4b6ed8d252b6621b2e351209f1"><td class="memItemLeft" align="right" valign="top">sockaddr *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1824f4b6ed8d252b6621b2e351209f1">sockaddr_ptr</a> () override</td></tr>
<tr class="memdesc:af1824f4b6ed8d252b6621b2e351209f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to this object cast to a <em>sockaddr</em>.  <br /></td></tr>
<tr class="separator:af1824f4b6ed8d252b6621b2e351209f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c96dc66e1d6686d02017ce2450166cd" id="r_a1c96dc66e1d6686d02017ce2450166cd"><td class="memItemLeft" align="right" valign="top">const sockaddr_can *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c96dc66e1d6686d02017ce2450166cd">sockaddr_can_ptr</a> () const</td></tr>
<tr class="memdesc:a1c96dc66e1d6686d02017ce2450166cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a const pointer to this object cast to a <em>sockaddr_can</em>.  <br /></td></tr>
<tr class="separator:a1c96dc66e1d6686d02017ce2450166cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab291475e8228e15dc3b5013a11788ca8" id="r_ab291475e8228e15dc3b5013a11788ca8"><td class="memItemLeft" align="right" valign="top">sockaddr_can *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab291475e8228e15dc3b5013a11788ca8">sockaddr_can_ptr</a> () noexcept</td></tr>
<tr class="memdesc:ab291475e8228e15dc3b5013a11788ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a pointer to this object cast to a <em>sockaddr_can</em>.  <br /></td></tr>
<tr class="separator:ab291475e8228e15dc3b5013a11788ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b32afe88a3a05aa1da94f9edf8f3e1" id="r_a94b32afe88a3a05aa1da94f9edf8f3e1"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94b32afe88a3a05aa1da94f9edf8f3e1">to_string</a> () const noexcept</td></tr>
<tr class="memdesc:a94b32afe88a3a05aa1da94f9edf8f3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a printable string for the address.  <br /></td></tr>
<tr class="separator:a94b32afe88a3a05aa1da94f9edf8f3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classsockpp_1_1sock__address"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classsockpp_1_1sock__address')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classsockpp_1_1sock__address.html">sockpp::sock_address</a></td></tr>
<tr class="memitem:a3016a2da6abc9730d1fbe32100b1ddd9 inherit pub_methods_classsockpp_1_1sock__address" id="r_a3016a2da6abc9730d1fbe32100b1ddd9"><td class="memItemLeft" align="right" valign="top">
virtual&#160;</td><td class="memItemRight" valign="bottom"><b>~sock_address</b> () noexcept</td></tr>
<tr class="memdesc:a3016a2da6abc9730d1fbe32100b1ddd9 inherit pub_methods_classsockpp_1_1sock__address"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor. <br /></td></tr>
<tr class="separator:a3016a2da6abc9730d1fbe32100b1ddd9 inherit pub_methods_classsockpp_1_1sock__address"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47688d3cff571fbf0c342c3d7885f97 inherit pub_methods_classsockpp_1_1sock__address" id="r_af47688d3cff571fbf0c342c3d7885f97"><td class="memItemLeft" align="right" valign="top">virtual sa_family_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsockpp_1_1sock__address.html#af47688d3cff571fbf0c342c3d7885f97">family</a> () const</td></tr>
<tr class="memdesc:af47688d3cff571fbf0c342c3d7885f97 inherit pub_methods_classsockpp_1_1sock__address"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the network family of the address.  <br /></td></tr>
<tr class="separator:af47688d3cff571fbf0c342c3d7885f97 inherit pub_methods_classsockpp_1_1sock__address"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78f06a210ab1b936d25d0a8a5a9d896 inherit pub_methods_classsockpp_1_1sock__address" id="r_ab78f06a210ab1b936d25d0a8a5a9d896"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsockpp_1_1sock__address.html#ab78f06a210ab1b936d25d0a8a5a9d896">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:ab78f06a210ab1b936d25d0a8a5a9d896 inherit pub_methods_classsockpp_1_1sock__address"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the address is set to some value.  <br /></td></tr>
<tr class="separator:ab78f06a210ab1b936d25d0a8a5a9d896 inherit pub_methods_classsockpp_1_1sock__address"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ace950e03bbccdaf743636e1ca439c49a" id="r_ace950e03bbccdaf743636e1ca439c49a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsockpp_1_1result.html">result</a>&lt; <a class="el" href="classsockpp_1_1can__address.html">can_address</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace950e03bbccdaf743636e1ca439c49a">create</a> (const string &amp;<a class="el" href="#adf220acee4858b2b7c7e6b051639e3e9">iface</a>)</td></tr>
<tr class="memdesc:ace950e03bbccdaf743636e1ca439c49a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to get the address for the secified CAN interface.  <br /></td></tr>
<tr class="separator:ace950e03bbccdaf743636e1ca439c49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9b8b86ec81ad879313b617c53c498039" id="r_a9b8b86ec81ad879313b617c53c498039"><td class="memItemLeft" align="right" valign="top"><a id="a9b8b86ec81ad879313b617c53c498039" name="a9b8b86ec81ad879313b617c53c498039"></a>
static constexpr sa_family_t&#160;</td><td class="memItemRight" valign="bottom"><b>ADDRESS_FAMILY</b> = AF_CAN</td></tr>
<tr class="memdesc:a9b8b86ec81ad879313b617c53c498039"><td class="mdescLeft">&#160;</td><td class="mdescRight">The address family for this type of address. <br /></td></tr>
<tr class="separator:a9b8b86ec81ad879313b617c53c498039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073807d79e842de516efcb07ee54ee19" id="r_a073807d79e842de516efcb07ee54ee19"><td class="memItemLeft" align="right" valign="top"><a id="a073807d79e842de516efcb07ee54ee19" name="a073807d79e842de516efcb07ee54ee19"></a>
static const unsigned&#160;</td><td class="memItemRight" valign="bottom"><b>ALL_IFACE</b> = 0</td></tr>
<tr class="memdesc:a073807d79e842de516efcb07ee54ee19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iface to use to indicate binding to all interfaces. <br /></td></tr>
<tr class="separator:a073807d79e842de516efcb07ee54ee19"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that represents a Linux SocketCAN address. </p>
<p>This inherits from the CAN form of a socket address, <em>sockaddr_can</em>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb52f2768042e8d148ea72dc3c78dbb4" name="abb52f2768042e8d148ea72dc3c78dbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb52f2768042e8d148ea72dc3c78dbb4">&#9670;&#160;</a></span>can_address() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sockpp::can_address::can_address </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an empty address. </p>
<p>The address is initialized to all zeroes. </p>

</div>
</div>
<a id="aeb99e1a7491496a17c61c05fdd1d141b" name="aeb99e1a7491496a17c61c05fdd1d141b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb99e1a7491496a17c61c05fdd1d141b">&#9670;&#160;</a></span>can_address() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sockpp::can_address::can_address </td>
          <td>(</td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an address for binding to a specific CAN interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The interface index to use. This must, obviously, be an index to a CAN interface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa634b4dc329dedd8d56f2413c79dd93c" name="aa634b4dc329dedd8d56f2413c79dd93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa634b4dc329dedd8d56f2413c79dd93c">&#9670;&#160;</a></span>can_address() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sockpp::can_address::can_address </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>iface</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an address for the specified CAN interface. </p>
<p>The interface might be "can0", "can1", "vcan0", etc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iface</td><td>The name of the CAN interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28adbdc672a05a282d6245f5961a5f0d" name="a28adbdc672a05a282d6245f5961a5f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28adbdc672a05a282d6245f5961a5f0d">&#9670;&#160;</a></span>can_address() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sockpp::can_address::can_address </td>
          <td>(</td>
          <td class="paramtype">const sockaddr &amp;</td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the address by copying the specified structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The generic address. This must be an AF_CAN address to be a valid CANbus address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fdc6027891cebad1244268e72301643" name="a3fdc6027891cebad1244268e72301643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdc6027891cebad1244268e72301643">&#9670;&#160;</a></span>can_address() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sockpp::can_address::can_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsockpp_1_1sock__address.html">sock_address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the address by copying the specified structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The other address. This must be an AF_CAN address to be a valid CANbus address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d0efbdc456d6df93cb62490ee7ec660" name="a9d0efbdc456d6df93cb62490ee7ec660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0efbdc456d6df93cb62490ee7ec660">&#9670;&#160;</a></span>can_address() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sockpp::can_address::can_address </td>
          <td>(</td>
          <td class="paramtype">const sockaddr_can &amp;</td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the address by copying the specified structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The other address. This must be initialized to a proper AF_CAN address to be valid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf49506a3fc0e0c2b670bebfdad9b52d" name="acf49506a3fc0e0c2b670bebfdad9b52d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf49506a3fc0e0c2b670bebfdad9b52d">&#9670;&#160;</a></span>can_address() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sockpp::can_address::can_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsockpp_1_1can__address.html">can_address</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>addr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the address by copying the specified address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The other address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace950e03bbccdaf743636e1ca439c49a" name="ace950e03bbccdaf743636e1ca439c49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace950e03bbccdaf743636e1ca439c49a">&#9670;&#160;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsockpp_1_1result.html">result</a>&lt; <a class="el" href="classsockpp_1_1can__address.html">can_address</a> &gt; sockpp::can_address::create </td>
          <td>(</td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>iface</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts to get the address for the secified CAN interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iface</td><td>The name of the CAN interface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A result with a CAN address, if successful, or an error code on failure. </dd></dl>

</div>
</div>
<a id="a85126b3fea2f25cf908eae1336d30391" name="a85126b3fea2f25cf908eae1336d30391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85126b3fea2f25cf908eae1336d30391">&#9670;&#160;</a></span>get_iface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsockpp_1_1result.html">result</a>&lt; string &gt; sockpp::can_address::get_iface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to get the name of the CAN interface for this address. </p>
<dl class="section return"><dt>Returns</dt><dd>The name of the CAN interface for this address. </dd></dl>

</div>
</div>
<a id="adf220acee4858b2b7c7e6b051639e3e9" name="adf220acee4858b2b7c7e6b051639e3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf220acee4858b2b7c7e6b051639e3e9">&#9670;&#160;</a></span>iface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string sockpp::can_address::iface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of the CAN interface for this address. </p>
<p>If the name can not be found or there's an error, returns "unknown". </p><dl class="section return"><dt>Returns</dt><dd>The name of the CAN interface for this address. </dd></dl>

</div>
</div>
<a id="a14bd23afd5ee4e16624b0ad3433e7590" name="a14bd23afd5ee4e16624b0ad3433e7590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bd23afd5ee4e16624b0ad3433e7590">&#9670;&#160;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int sockpp::can_address::index </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the index of the CAN interface for this address. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the CAN interface for this address. </dd></dl>

</div>
</div>
<a id="a0e93d75f42bf1b4939500b68307f28eb" name="a0e93d75f42bf1b4939500b68307f28eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e93d75f42bf1b4939500b68307f28eb">&#9670;&#160;</a></span>is_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sockpp::can_address::is_set </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the address is set to some value. </p>
<p>This doesn't attempt to determine if the address is valid, simply that it's not all zero. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em> if the address has been set, <em>false</em> otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="classsockpp_1_1sock__address.html#ac4e5b06da0efbbc6b8d289e3215f13aa">sockpp::sock_address</a>.</p>

</div>
</div>
<a id="af6e78e39748afb7db8a7285557994134" name="af6e78e39748afb7db8a7285557994134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e78e39748afb7db8a7285557994134">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">socklen_t sockpp::can_address::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of the address structure. </p>
<p>Note: In this implementation, this should return sizeof(this) but more convenient in some places, and the implementation might change in the future, so it might be more compatible with future revisions to use this call. </p><dl class="section return"><dt>Returns</dt><dd>The size of the address structure. </dd></dl>

<p>Implements <a class="el" href="classsockpp_1_1sock__address.html#adf9f4a69071562366ea6d5e50258c281">sockpp::sock_address</a>.</p>

</div>
</div>
<a id="a1c96dc66e1d6686d02017ce2450166cd" name="a1c96dc66e1d6686d02017ce2450166cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c96dc66e1d6686d02017ce2450166cd">&#9670;&#160;</a></span>sockaddr_can_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const sockaddr_can * sockpp::can_address::sockaddr_can_ptr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a const pointer to this object cast to a <em>sockaddr_can</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>const sockaddr_can pointer to this object. </dd></dl>

</div>
</div>
<a id="ab291475e8228e15dc3b5013a11788ca8" name="ab291475e8228e15dc3b5013a11788ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab291475e8228e15dc3b5013a11788ca8">&#9670;&#160;</a></span>sockaddr_can_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sockaddr_can * sockpp::can_address::sockaddr_can_ptr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to this object cast to a <em>sockaddr_can</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>sockaddr_can pointer to this object. </dd></dl>

</div>
</div>
<a id="ab28b359f745395930b01090f59aacf79" name="ab28b359f745395930b01090f59aacf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28b359f745395930b01090f59aacf79">&#9670;&#160;</a></span>sockaddr_ptr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const sockaddr * sockpp::can_address::sockaddr_ptr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to this object cast to a const <em>sockaddr</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this object cast to a const <em>sockaddr</em>. </dd></dl>

<p>Implements <a class="el" href="classsockpp_1_1sock__address.html#a3a9cb6445288251aa463529d84b7801d">sockpp::sock_address</a>.</p>

</div>
</div>
<a id="af1824f4b6ed8d252b6621b2e351209f1" name="af1824f4b6ed8d252b6621b2e351209f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1824f4b6ed8d252b6621b2e351209f1">&#9670;&#160;</a></span>sockaddr_ptr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sockaddr * sockpp::can_address::sockaddr_ptr </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a pointer to this object cast to a <em>sockaddr</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to this object cast to a <em>sockaddr</em>. </dd></dl>

<p>Implements <a class="el" href="classsockpp_1_1sock__address.html#a024c74ac9d3fe8cd5284b82f1f2d33e2">sockpp::sock_address</a>.</p>

</div>
</div>
<a id="a94b32afe88a3a05aa1da94f9edf8f3e1" name="a94b32afe88a3a05aa1da94f9edf8f3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94b32afe88a3a05aa1da94f9edf8f3e1">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string sockpp::can_address::to_string </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets a printable string for the address. </p>
<dl class="section return"><dt>Returns</dt><dd>A string representation of the address in the form "unix:&lt;path&gt;" </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/sockpp/<a class="el" href="can__address_8h_source.html">can_address.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 14 2024 17:38:17 for sockpp by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
